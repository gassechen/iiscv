#+TITLE: IISCV System Documentation

* IISCV System Documentation

=iiscv= is an interactive and introspective version control system for Common Lisp. Unlike external systems like =Git=, =iiscv= operates directly within the Lisp image, capturing every function, macro, class definition, etc., as an "atomic commit." It then allows grouping these atomic commits into more meaningful "human commits," creating a dual history: one for the machine (complete and detailed) and another for humans (curated and readable).

** Main Concepts and Global Variables

The system is based on two history graphs and a hash table for symbol tracking.

*** =*atomic-history-graph*=
A graph that stores every individual and atomic change. Each time a function, class, etc., is defined or redefined, a new node (vertex) is created in this graph. It functions as an immutable and complete record of every evaluation in the REPL.

*** =*human-history-graph*=
A higher-level graph that stores project "milestones." A human commit groups one or more atomic commits under a single descriptive message, similar to a commit in =Git=. This provides a curated and readable view of the project's progress.

*** =*function-to-uuid-map*=
A hash table that maps a symbol's full name (e.g., ="IISCV::MAKE-ATOMIC-COMMIT"=) to its *latest* atomic commit UUID. This allows for quickly finding the most recent version of any function or definition.

-----

** Commit Creation

These are the core functions for recording changes in the system.

*** =make-atomic-commit=
#+BEGIN_SRC lisp
(defun make-atomic-commit (definition-form))
#+END_SRC

This is the system's main function. It is responsible for creating an *atomic commit* each time a new definition (=defun=, =defclass=, etc.) is evaluated.

*Actions performed:*
1.  *Analyzes the code*:: Extracts metrics and metadata from the =definition-form= (the definition's source code), such as cyclomatic complexity, presence of docstrings, magic numbers, etc.
2.  *Generates a UUID*:: Creates a universal unique identifier (=UUID=) for this commit.
3.  *Runs audits*:: Calls =analyze-commit-and-assert= to populate the =LISA= inference engine's knowledge base and detect quality rule violations.
4.  *Creates the commit*:: Stores the source code, UUID, timestamp, and detected violations in a =commit-data= object.
5.  *Updates the graph*:: Adds a new vertex to =*atomic-history-graph*= with the commit data and links it to the previous atomic commit.
6.  *Updates the symbol map*:: Associates the function/symbol name with the new UUID in =*function-to-uuid-map*=.
7.  *Generates an audit file*:: Calls =make-file-commit= to create a Rove test file, ensuring the form can be evaluated without errors in the future.

*** =human-commit=
#+BEGIN_SRC lisp
(defun human-commit (message symbols &optional (file-path nil)))
#+END_SRC

Creates a high-level *human commit*. This is the function a developer uses to mark a milestone or a set of related changes.

*Parameters:*
- =message= :: A descriptive string for the change, similar to a Git commit message.
- =symbols= :: A list of symbols (e.g., ='(my-function another-function)=) whose latest atomic commits will be grouped under this human commit.
- =file-path= (optional) :: If provided, can be used to write the code to a file (this functionality is commented out in the current code).

*Actions performed:*
1.  Finds the UUIDs of the latest atomic commits for each symbol in the =symbols= list.
2.  Creates a new UUID for the human commit.
3.  Adds a vertex to the =*human-history-graph*= containing the message, the list of associated atomic UUIDs, and the timestamp.
4.  Links this new human commit to the previous one.

-----

** User Interface (REPL)

*** =iiscv-repl=
#+BEGIN_SRC lisp
(defun iiscv-repl ())
#+END_SRC

Starts a custom Read-Eval-Print-Loop (REPL). This REPL is the core of the user's interaction with the system.

*How it works:*
1.  Reads a Lisp form (=read=).
2.  Evaluates the form (=eval=).
3.  *Checks if it's a definition*:: Using =get-docstring-type=, it determines if the form is a =defun=, =defclass=, etc.
4.  *Creates an atomic commit*:: If it is a registered definition type, it automatically calls =make-atomic-commit= with the form's code.
5.  Prints the result (=print=), unless the result is =:no-print=.
6.  Handles errors gracefully so the REPL does not crash.

-----

** Querying and Retrieving Data

These functions allow searching and retrieving information from the commit history.

*** =get-last-uuid-by-name=
#+BEGIN_SRC lisp
(defun get-last-uuid-by-name (name-symbol))
#+END_SRC
Returns the UUID of the most recent atomic commit for a given symbol. It uses =*function-to-uuid-map*= for the lookup.

*** =get-source-form-by-uuid=
#+BEGIN_SRC lisp
(defun get-source-form-by-uuid (uuid))
#+END_SRC
Given a UUID, it searches the =*atomic-history-graph*= for the corresponding commit and returns its source code (=:source-form=).

*** =get-source-form=
#+BEGIN_SRC lisp
(defun get-source-form (function-name &key full-commit-p))
#+END_SRC
A convenience function to get the source code of a function by its name (as a string). If =full-commit-p= is =T=, it returns the entire commit data, not just the source code.

*** =get-class-source-form=
#+BEGIN_SRC lisp
(defun get-class-source-form (class-name))
#+END_SRC
Specialized for classes, this retrieves the original =defclass= form from the atomic history.

-----

** Granular Class Manipulation

These macros allow for programmatically modifying existing classes, recording each change as a new commit.

*** =add-slot=
#+BEGIN_SRC lisp
(defmacro add-slot (class-name slot-definition))
#+END_SRC
Adds a new slot to an existing class.
1.  Retrieves the class's current =defclass= form from the history.
2.  Constructs a new =defclass= form with the added slot.
3.  Evaluates (=eval=) the new definition, which redefines the class and (if used within the =iiscv-repl=) triggers a =make-atomic-commit= for the new class version.

*** =remove-slot=
#+BEGIN_SRC lisp
(defmacro remove-slot (class-name slot-name))
#+END_SRC
Removes a slot from an existing class. It works similarly to =add-slot= but filters out the specified slot.

-----

** History Visualization

Functions to inspect the commit graphs.

*** =show-atomic-commit=
#+BEGIN_SRC lisp
(defun show-atomic-commit ())
#+END_SRC
Returns a list of all vertices (commits) in the =*atomic-history-graph*=.

*** =show-human-commit=
#+BEGIN_SRC lisp
(defun show-human-commit ())
#+END_SRC
Returns a list of all vertices (commits) in the =*human-history-graph*=.

*** =show-project-milestones=
#+BEGIN_SRC lisp
(defun show-project-milestones ())
#+END_SRC
Displays a formatted, readable view of the human history, presenting each commit with its message, UUID, and the atomic changes it groups.

*** =audit-atomic-history=
#+BEGIN_SRC lisp
(defun audit-atomic-history ())
#+END_SRC
Displays a detailed and complete view of the atomic history, including each commit's UUID, its source code, and any detected audit violations.

-----

** System Reconstruction

Allows regenerating the Lisp system's state from the saved history.

*** =rebuild-image-from-atomic-history=
#+BEGIN_SRC lisp
(defun rebuild-image-from-atomic-history ())
#+END_SRC
Traverses the *entire* atomic history in chronological order (=topological-sort=) and evaluates each =source-form=. This is a full recovery tool that restores the system to its last state, including every intermediate step.

*** =rebuild-image-from-human-history=
#+BEGIN_SRC lisp
(defun rebuild-image-from-human-history ())
#+END_SRC
Traverses the human history and evaluates only the atomic commits that were explicitly included in human commits. This allows for a "clean" reconstruction, ignoring experimental code or intermediate refactorings that did not become part of a milestone.

-----

** Integration with Auditing and Testing (Rove)

The system integrates with the =Rove= testing library to create a continuous audit trail.

*** =make-file-commit=
#+BEGIN_SRC lisp
(defun make-file-commit (commit-uuid form))
#+END_SRC
For each atomic commit, this function creates a =.lisp= file in the =audits/= directory. The file contains a Rove test (=deftest=) that simply verifies that the commit's code (=form=) can be evaluated without error.

*** =run-all-audits=
#+BEGIN_SRC lisp
(defun run-all-audits ())
#+END_SRC
Finds and loads all the audit files generated by =make-file-commit= and then runs the Rove test suite. This ensures that all commits in the history remain valid and executable.

-----

** Helper Functions

*** =get-docstring-type= / =register-commit-type=
#+BEGIN_SRC lisp
(defun get-docstring-type (form))
(defun register-commit-type (form-name commit-type))
#+END_SRC
A simple registry system so the =iiscv-repl= knows which types of forms should be treated as commits (e.g., =defun=, =defvar=, =defclass=). =register-commit-type= adds a form to the registry, and =get-docstring-type= queries it.

*** =find-vertex-by-uuid=
#+BEGIN_SRC lisp
(defun find-vertex-by-uuid (graph uuid))
#+END_SRC
A utility function that iterates over the vertices of a graph (=cl-graph=) to find one matching a specific UUID.
