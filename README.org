#+TITLE: IISCV Project: A Common Lisp Auditable Development System
#+AUTHOR: [Your Name]
#+DATE: 2025-08-21

* Introduction
IISCV is a project aimed at **reviving the image-based development paradigm** inherent to Common Lisp, adapting it with a unique layer of internal and external auditability. This system transforms the traditional "edit-compile-run" cycle into a resilient and auditable workflow, ensuring every functional change is automatically recorded and verifiable.

* Project Objective and Philosophy
Our objective is to revive the **image-based software development paradigm**, inherent to Lisp, and adapt it with a layer of internal and external auditability. Historically, this paradigm was surpassed by file-based systems, mainly due to the lack of robust and standardized auditing tools. We seek to solve this weak point to demonstrate that this approach is viable and superior for certain software domains.

The working philosophy that drives this system is **debugging and development by incremental substitution**. Instead of an "edit-compile-run" cycle, our approach is a continuous process of "evaluate-debug-replace" in the live program environment. This allows for an auditable record of every functional change, acting as a "laboratory journal" where every idea, every functional experiment, is recorded and verified.

* Key Features
- **Real-time Auditing:** Automatically creates a permanent audit trail for every top-level Lisp form (`defun`, `defvar`, etc.) evaluated within its custom REPL.
- **Version Control for a Live Image:** Provides a Git-like system (`get-commit-form`, `get-last-uuid-by-name`) to navigate and recover code from a live, running Lisp image.
- **Integrated Testing:** Every commit is saved as a Rove test file, allowing for a comprehensive audit of the entire project history with a single command.
- **Resilience:** Mitigates the common "Excel problem" of unrecorded changes by ensuring every functional change is a verifiable commit.

* Installation

1.  Ensure you have **Quicklisp** installed and configured.
2.  Clone this repository into your `quicklisp/local-projects/` directory.

    #+begin_src sh
    git clone https://github.com/gassechen/iiscv.git quicklisp/local-projects/iiscv
    #+end_src

3.  Load the system in your Lisp REPL.

    #+begin_src lisp
    (ql:quickload :iiscv)
    #+end_src

* Usage

1.  **Start the custom REPL:**
    #+begin_src lisp
    (iiscv:iiscv-repl)
    #+end_src
    You will see a new prompt, `IISCV-R>`, indicating that you are in the auditable environment.

2.  **Define a function:**
    #+begin_src lisp
    (defun my-function (x)
      "A simple function that will be audited."
      (* x 2))
    #+end_src
    The system will automatically generate a UUID and save the code as a commit.

3.  **Run an audit:**
    #+begin_src lisp
    (run-all-audits)
    #+end_src
    This command will run all saved tests and verify that every function in your history is working as expected.

* TODO: Development Tasks
- [X] Define the `commit` structure (hash, message, etc.).
- [X] Implement the `hash` to identify `commits`.
- [X] Implement the `make-commit` function to create `commits` in memory.
- [X] Ensure `make-commit` is generic enough to handle `defun`, `defvar`, etc.
- [X] Decide and formalize the decision not to implement the `revert` function.
- [X] Implement the `make-state-snapshot` function to audit the state of variables.
- [X] Design the "file bridge" for external auditability.
- [X] Design the audit format as an executable test with `rove`.
- [X] Implement the `make-file-commit` function that writes audit files.
- [ ] Integrate `make-file-commit` with Git (using an external call).
- [X] Design the wrapping REPL (`iiscv-repl`).
- [X] Implement the REPL logic that evaluates and makes automatic `commits`.
- [X] Test the full "evaluate-commit-audit" flow within the REPL.
- [ ] Implement a function to browse the history (`browse-history`).
- [ ] Consider including additional metadata in the `commit` (author, date).





1. La Nueva Arquitectura del Sistema
Tu sistema pasaría de tener un solo registro (*history*) a tener dos:

*atomic-history* (La Historia para la Máquina): La tabla hash que ya tienes. Seguiría guardando cada defun o defvar de forma automática, con un UUID único y un mensaje de commit genérico (ej. "Definición de función"). Esta historia es inmutable y completa.

*human-history* (La Historia para los Humanos): Esta sería la nueva tabla hash. Su propósito es guardar los commits de alto nivel. Cada entrada tendría un mensaje escrito por el desarrollador (ej. "Solución al error 352") y una lista de los UUIDs de los commits atómicos que se incluyeron en ese cambio.

2. El Nuevo Flujo de Trabajo
El proceso de desarrollo y auditoría cambiaría para reflejar esta dualidad:

Desarrollo en el REPL (iiscv-repl): Seguirías trabajando de forma normal. Cada defun o defvar que evalúes seguiría creando un commit automático en el *atomic-history*, pero no sería un commit oficial. Sería como un "staging area".

El Commit para Humanos: Cuando estés satisfecho con una serie de cambios (por ejemplo, has creado una función, una variable y una macro para resolver un problema), usarías un nuevo comando para agrupar esos commits atómicos.

Lisp

(iiscv:commit "Arreglo del error #45 en el cálculo de impuestos."
              'calculate-tax
              '*tax-brackets*'
              'get-tax-rate)
Este comando tomaría los UUIDs de los commits atómicos de esas funciones y los guardaría en una nueva entrada en la tabla *human-history*, con el mensaje que escribiste.

3. Reconstrucción de la Imagen (Rebuild)
Aquí es donde se vería la diferencia más grande. La función rebuild-image-from-history ya no tendría que recorrer cada commit atómico de forma individual. En su lugar, el proceso sería así:

Cargar el Historial para Humanos: La función primero cargaría el *human-history*.

Recorrer el Historial de Alto Nivel: Luego, iteraría sobre cada commit de alto nivel. Para cada uno de ellos, tomaría la lista de UUIDs de commits atómicos.

Reconstruir con commits Atómicos: Usaría esa lista de UUIDs para buscar y evaluar el código correspondiente en la tabla *atomic-history*.

La principal ventaja es que el proceso de reconstrucción podría ser mucho más eficiente y legible, ya que seguiría la misma lógica que un desarrollador humano. En lugar de reconstruir una historia llena de prueba y error, reconstruiría una historia limpia y con significado.


Verificación del Historial: Un Paso Crítico
Para evitar ese escenario, el sistema debe incorporar una función de auditoría que garantice que la capa de human-history sea una representación completa de la atomic-history.

Podrías implementar una nueva función: (iiscv:verificar-historial).

Este proceso de verificación haría lo siguiente:

Comparar las historias: La función recorrería la atomic-history (la fuente de la verdad) y la compararía con la human-history.

Identificar cambios perdidos: Buscaría cualquier UUID en la atomic-history que no esté referenciado en ningún commit del human-history.

Advertir al desarrollador: Si encuentra cambios no enlazados, el sistema no permitiría la reconstrucción y le mostraría al desarrollador una lista de las funciones que faltan.

Este paso de verificación garantiza que la reconstrucción basada en el human-history sea tan confiable como una reconstrucción completa de la atomic-history, sin sacrificar la velocidad ni la legibilidad. Es un mecanismo de seguridad que previene la creación de imágenes defectuosas de forma silenciosa. Con esto, el sistema se vuelve robusto contra los errores humanos.
